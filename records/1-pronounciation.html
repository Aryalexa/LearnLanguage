<!doctype html>
<html>
<head>
    <title>Pronounciation</title>

    <meta charset="utf-8" />
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
    <link rel="stylesheet" href="css/main.css">
    <link href='https://fonts.googleapis.com/css?family=Lato:400,300,700' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Lobster' rel='stylesheet' type='text/css'>
    <link href='https://fonts.googleapis.com/css?family=Dosis' rel='stylesheet' type='text/css'>

</head>

<body>
<div class="all">
  <h1>Pronounciation</h1>
  <h2 class="font-dosis green">HHH</h2>
  <h3>Pitch detection algorithm (PDA)</h3>
  <h4>JJJJJJ</h4>
  <h5>KKKKKKKK</h5>
  <p>
    Un algoritmo de detección de tono/altura (PDA) es un algoritmo diseñado para
    estimar el tono o frecuencia fundamental de una señal quasiperiodic u
    oscilante, por lo general una grabación digital de voz o una nota musical
    o tono.
    Esto puede hacerse en el dominio del tiempo o en el dominio de frecuencia
    o ambos los dos dominios.
  </p>
  <h4>Aproximacion de dominio de tiempo</h4>
  <p>

  </p>
  <h4>Aproximacion de dominio de frecuencia</h4>
  <p>

  </p>
  <h4>Aproximacion temporal/espectral</h4>
  <p>
    Los algoritmos como el YAAPT se basan en una combinacion de procesamiento en
    dominio de tiempo utilizando una funcion de
    <a href="https://en.wikipedia.org/wiki/Autocorrelation">autocorrelacion</a>
    tal como normalized cross correlation y de procesamiento en dominio de frecuencia
    utilizando informacion espectral para identificar el tono.
    Then, among the candidates estimated from the two domains, a final pitch
    track can be computed using dynamic programming.
    La ventaja de estas aproximaciones es que el error de seguimiento puede ser
    reducido por el procesamiento del otro dominio.
  </p>
  <h4>Frecuencia fundamnetal del habla</h4>
  <p>
    Varía entre 40 Hz para tonos bajos y tonos altos de 600 Hz.
    Los métodos de autocorrelación necesitan al menos dos periodos para detectar el habla.
    Esto significa que para una freuancia fundamental de 40 Hz, al menos 50 ms
    de señal de habla debe ser analizado. Sin embargo, durante 50 ms, el habla
    con frecuencia fundamental muy alta no tiene necesariamente la misma frecuancia
    fundamental para toda la ventana.
  </p>



<h3>recording</h3>
<p>
  La modulación por impulsos codificados (MIC o PCM por las siglas en inglés de
  Pulse Code Modulation).
  <br>Tenemos a sequence of numbers representing the amplitude of audio over time
  "Linear, PCM audio" (se obtiene de most uncompressed audio formats like AIFF
  and WAV. If you have a compressed format such as MP3 or OGG, you will have
  to convert it to uncompressed audio first.)
  <br>AudioRecord class >
  read(byte[] audioData, int offsetInBytes, int sizeInBytes) method >>
  Reads audio data from the audio hardware for recording into a byte array.
  The format specified in the AudioRecord constructor should be ENCODING_PCM_8BIT
  to correspond to the data in the array.
  <br>You'll also need to know how often your audio is sampled.
  Cada cuanto se toman muestras del audio, la frecuencia:
  (44.1 kHz is considered standard for audio and 48 kHz is standard for video),
  usamos 44100 Hz.
  <br>Grabamos un archivo .raw en el internal storage.
</p>
<h3>filtering</h3>
<p>
  In signal processing, a finite impulse response (FIR) filter is a filter whose
  impulse response (or response to any finite length input) is of finite duration,
  because it settles to zero in finite time. This is in contrast to infinite
  impulse response (IIR) filters, which may have internal feedback and may continue
  to respond indefinitely (usually decaying).
  <br>For a FIR filter of order N,
  each value of the output sequence is a weighted sum of the most recent input values
  <br>One may speak of a 5th order/6-tap filter.
  <br>An FIR filter is designed by finding the <b>coefficients</b> and
  <b>filter order</b> that meet certain specifications, which can be in the time-domain
  (e.g. a matched filter) and/or the frequency domain (most common).
  <br>Un filtro IIR tambien calcula sus coeficientes y actua.
</p>




  <hr> <!-- __________________________________________________________ -->
  <h4>Sources</h4>
  <ol>
    <li>
      <a href="https://en.wikipedia.org/wiki/Pitch_detection_algorithm">
        wiki - Pitch detection algorithm</a>
    </li>
    <li>
      <a href="http://blog.bjornroche.com/2012/07/frequency-detection-using-fft-aka-pitch.html?m=0">
      bjorn - spitch tracking</a>
    </li>
    <li>
      <a href="http://blog.bjornroche.com/2012/08/why-eq-is-done-in-time-domain.html?m=0">
      Why EQ/filtering Is Done In the Time Domain</a>
    </li>
    <li>
      wiki - FIR, IIR
    </li>

  </ol>
</div>

</body>
</html>
